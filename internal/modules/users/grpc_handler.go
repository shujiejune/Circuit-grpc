package users

import (
	"context"
	"dispatch-and-delivery/internal/models"
	pb "dispatch-and-delivery/pkg/proto/user"
	"dispatch-and-delivery/pkg/utils"
	"errors"

	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/types/known/timestamppb"
)

// GRPCHandler is the gRPC handler for the user service.
// It implements the UserServiceServer interface generated by protoc.
type GRPCHandler struct {
	// It must embed this to forward-compatibly implement the interface.
	pb.UnimplementedUserServiceServer

	// It holds a dependency on the core business logic service.
	service ServiceInterface
}

// NewGRPCHandler creates a new gRPC handler for the user service.
func NewGRPCHandler(s ServiceInterface) *GRPCHandler {
	return &GRPCHandler{service: s}
}

// RegisterUser handles the gRPC request for creating a new user.
func (h *GRPCHandler) RegisterUser(ctx context.Context, req *pb.RegisterUserRequest) (*pb.RegisterUserResponse, error) {
	// In gRPC, validation should happen here or in the service layer.
	authRes, err := h.service.Signup(ctx, models.SignupRequest{Nickname: req.Name, Email: req.Email, Password: req.Password})
	if err != nil {
		// Translate domain errors to gRPC status codes
		if errors.Is(err, models.ErrConflict) {
			return nil, status.Error(codes.AlreadyExists, "email address is already in use")
		}
		return nil, status.Error(codes.Internal, "failed to create user")
	}
	return &pb.AuthResponse{AccessToken: authRes.AccessToken}, nil
}

// LoginUser handles the gRPC request for authenticating a user.
func (h *GRPCHandler) LoginUser(ctx context.Context, req *pb.LoginUserRequest) (*pb.LoginUserResponse, error) {
	authRes, err := h.service.Login(ctx, models.LoginRequest{Email: req.Email, Password: req.Password})
	if err != nil {
		if errors.Is(err, models.ErrInvalidCredentials) {
			return nil, status.Error(codes.Unauthenticated, "invalid email or password")
		}
		return nil, status.Error(codes.Internal, "failed to log in")
	}
	return &pb.AuthResponse{AccessToken: authRes.AccessToken}, nil
}

func (h *GRPCHandler) ActivateAccount(ctx context.Context, req *pb.ActivateAccountRequest) (*pb.AuthResponse, error) {
	authRes, err := h.service.ActivateUserAndLogin(ctx, req.Token)
	if err != nil {
		if errors.Is(err, models.ErrInvalidToken) {
			return nil, status.Error(codes.InvalidArgument, "invalid or expired activation token")
		}
		return nil, status.Error(codes.Internal, "failed to activate account")
	}
	return &pb.AuthResponse{AccessToken: authRes.AccessToken}, nil
}

// GetUserProfile handles the gRPC request for fetching a user's profile.
func (h *GRPCHandler) GetUserProfile(ctx context.Context, req *pb.GetUserProfileRequest) (*pb.GetUserProfileResponse, error) {
	userID, err := utils.GetUserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	user, err := h.service.GetUserProfile(ctx, userID)
	if err != nil {
		if errors.Is(err, models.ErrNotFound) {
			return nil, status.Error(codes.NotFound, "user profile not found")
		}
		return nil, status.Error(codes.Internal, "failed to retrieve profile")
	}

	return &pb.GetUserProfileResponse{
		Id:        user.ID,
		Name:      user.Nickname,
		Email:     user.Email,
		CreatedAt: timestamppb.New(user.CreatedAt),
		UpdatedAt: timestamppb.New(user.UpdatedAt),
	}, nil
}
